game:GetService("StarterGui"):SetCore("SendNotification",{
    Title = "Fe martelo C00lkid loading...",
    Text = "Made by Jinxx0g :3 - Modified with Bug System",
    Button1 = "okie",
    Button2 = "-",
    Duration = 30
})

wait(1)

-- // ServiÃ§os
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- // VariÃ¡veis
local buggedPlayers = {}
local bugConnections = {}
local Remote = ReplicatedStorage.RE:FindFirstChild("1Gu1n")

-- // FunÃ§Ã£o de notificaÃ§Ã£o
local function createNotification(title, message, duration)
    game:GetService("StarterGui"):SetCore("SendNotification",{
        Title = title,
        Text = message,
        Duration = duration or 3
    })
end

-- // FunÃ§Ã£o para aplicar bug em um player
local function bugPlayer(targetPlayer)
    if not Remote then
        createNotification("âŒ Erro", "Remote nÃ£o encontrado!")
        return
    end
    
    if not targetPlayer or not targetPlayer.Character then
        createNotification("âŒ Erro", "Player invÃ¡lido!")
        return
    end
    
    local playerName = targetPlayer.Name
    
    if buggedPlayers[playerName] then
        if bugConnections[playerName] then
            bugConnections[playerName]:Disconnect()
            bugConnections[playerName] = nil
        end
        buggedPlayers[playerName] = nil
        createNotification("ğŸ”“ Bug Parado", playerName .. " foi desbugado!")
        return
    end
    
    buggedPlayers[playerName] = true
    createNotification("Bug Aplicado", playerName .. " foi bugado com o Hammer goner!")
    
    bugConnections[playerName] = RunService.Stepped:Connect(function()
        local target = Players:FindFirstChild(playerName)
        if not target or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then
            if bugConnections[playerName] then
                bugConnections[playerName]:Disconnect()
                bugConnections[playerName] = nil
            end
            buggedPlayers[playerName] = nil
            return
        end
        
        local crazyVector = Vector3.new(
            math.random(1e25, 1e25),
            math.random(1e25, 1e25),
            math.random(1e25, 1e25)
        )
        
        local args = {
            [1] = target.Character.HumanoidRootPart,
            [2] = target.Character.HumanoidRootPart,
            [3] = crazyVector,
            [4] = target.Character.HumanoidRootPart.Position,
            [5] = LocalPlayer.Backpack:FindFirstChild("Assault") and LocalPlayer.Backpack.Assault.GunScript_Local:FindFirstChild("MuzzleEffect"),
            [6] = LocalPlayer.Backpack:FindFirstChild("Assault") and LocalPlayer.Backpack.Assault.GunScript_Local:FindFirstChild("HitEffect"),
            [7] = 3000,
            [8] = 3000,
            [9] = { [1] = false },
            [10] = {
                [1] = 10000,
                [2] = Vector3.new(3000, 3000, 3000),
                [3] = BrickColor.new(29),
                [4] = 0.05,
                [5] = Enum.Material.SmoothPlastic,
                [6] = 0.05
            },
            [11] = true,
            [12] = false
        }
        
        Remote:FireServer(unpack(args))
    end)
end

-- // Detecta player clicado
local function getPlayerFromMouse(mouse)
    local target = mouse.Target
    if not target then return nil end
    local character = target.Parent
    while character and not character:FindFirstChild("Humanoid") do
        character = character.Parent
    end
    if character and character:FindFirstChild("Humanoid") then
        return Players:GetPlayerFromCharacter(character)
    end
    return nil
end

-- // NOVOS IDs para equipar
local itemIDs = {
    23530382965577,
    96500960036542,
    74489903163302,
    85785002967842,
    892267099,
    892268340,
    892265784,
    12953810964585,
    126214685679099,
    135129962352322
}

-- // FunÃ§Ã£o para executar scripts externos primeiro
local function executeExternalScripts()
    local externalScripts = {
        "https://raw.githubusercontent.com/267266273ffsfs/sumir/refs/heads/main/Main.txt",
        "https://raw.githubusercontent.com/267266273ffsfs/reaparecer/refs/heads/main/Main.txt",
        "https://raw.githubusercontent.com/267266273ffsfs/c00lkid/refs/heads/main/Main.txt",
        "https://raw.githubusercontent.com/267266273ffsfs/c00lkidspeed/refs/heads/main/Main.txt",
        "https://raw.githubusercontent.com/267266273ffsfs/flutuar/refs/heads/main/Main.txt"
    }

    for _, url in ipairs(externalScripts) do
        local success, err = pcall(function()
            loadstring(game:HttpGet(url))()
        end)
        if success then
            print("âœ… Script externo carregado: "..url)
        else
            warn("âš ï¸ Falha ao carregar script externo: "..url.." | "..tostring(err))
        end
        task.wait(0.3)
    end
end

-- // FunÃ§Ã£o para equipar itens + executar Remotes
local function equipItemsAndRemotes(list)
    local seen, uniqueList = {}, {}
    for _, id in ipairs(list) do
        if not seen[id] then
            seen[id] = true
            table.insert(uniqueList, id)
        end
    end

    for _, id in ipairs(uniqueList) do
        local success, err = pcall(function()
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Wear"):InvokeServer(id)
        end)
        if success then
            print("âœ… Item ID "..id.." equipado com sucesso!")
        else
            warn("âš ï¸ Falha ao equipar Item ID "..id.." | "..tostring(err))
        end
        task.wait(0.3)
    end

    -- Executa ChangeBodyColor
    local bodyColorRemote = ReplicatedStorage:WaitForChild("Remotes"):FindFirstChild("ChangeBodyColor")
    if bodyColorRemote then
        bodyColorRemote:FireServer("Really black")
        print("ğŸ¨ Remote ChangeBodyColor executado com sucesso!")
    else
        warn("âŒ Remote ChangeBodyColor nÃ£o encontrado!")
    end

    -- LOOP infinito do ApplyEmmiter para os dois remotes
    task.spawn(function()
        local applyEmitterRemote = ReplicatedStorage:WaitForChild("Remotes"):FindFirstChild("ApplyEmmiter")
        if not applyEmitterRemote then
            warn("âŒ Remote ApplyEmmiter nÃ£o encontrado!")
            return
        end
        while task.wait(1) do
            pcall(function()
                -- Emitter antigo
                applyEmitterRemote:InvokeServer(18635845425, "087SmokeBlack")
                -- Novo emitter adicionado
                applyEmitterRemote:InvokeServer(18637796598, "086SmokeRed")
            end)
        end
    end)
end

-- // FunÃ§Ã£o para criar e adicionar a Tool ao inventÃ¡rio
local function createAndAddTool()
    local tool = Instance.new("Tool")
    tool.Name = "Hammer C00lkid"
    tool.RequiresHandle = true
    tool.CanBeDropped = true

    local handle = Instance.new("Part")
    handle.Name = "Handle"
    handle.Size = Vector3.new(0.1, 0.1, 0.1)
    handle.Massless = true
    handle.Anchored = false
    handle.CanCollide = false
    handle.Transparency = 0.5
    handle.Color = Color3.fromRGB(255, 0, 0)
    local mesh = Instance.new("SpecialMesh", handle)
    mesh.MeshType = Enum.MeshType.Sphere
    mesh.Scale = Vector3.new(0.05, 0.05, 0.05)
    handle.Parent = tool

    tool.Parent = LocalPlayer.Backpack
    createNotification("âœ… Hammer C00lkid Carregado", "Tool adicionada ao inventÃ¡rio!")

    return tool
end

-- // EXECUÃ‡ÃƒO PRINCIPAL
task.spawn(function()
    executeExternalScripts()
    local tool = createAndAddTool()
    equipItemsAndRemotes(itemIDs)

    tool.Equipped:Connect(function(mouse)
        local character = tool.Parent
        if character and character:FindFirstChild("Humanoid") and character.Humanoid.RigType == Enum.HumanoidRigType.R15 then
            local args = {15250108533}
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Wear"):InvokeServer(unpack(args))
            
            mouse.Button1Down:Connect(function()
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local animator = humanoid and humanoid:FindFirstChildOfClass("Animator")
                if animator then
                    local anim = Instance.new("Animation")
                    anim.AnimationId = "rbxassetid://2410679501"
                    local track = animator:LoadAnimation(anim)
                    track:Play()
                end
                
                local targetPlayer = getPlayerFromMouse(mouse)
                if targetPlayer and targetPlayer ~= LocalPlayer then
                    bugPlayer(targetPlayer)
                else
                    createNotification("ğŸ’¡ Info", "Clique em um player para aplicar/remover o bug!")
                end
            end)
            
            createNotification("Hammer C00lkid Equipado", "Clique em players para aplicar/remover bug!")
        end
    end)

    tool.Unequipped:Connect(function()
        local args = {15250108533}
        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Wear"):InvokeServer(unpack(args))
        createNotification("coolkid bug hammer Guardado", "Tool desequipado! Visual restaurado.") 
    end)
end)

-- // Limpeza quando player sai
Players.PlayerRemoving:Connect(function(player)
    local playerName = player.Name
    if bugConnections[playerName] then
        bugConnections[playerName]:Disconnect()
        bugConnections[playerName] = nil
    end
    buggedPlayers[playerName] = nil
end)

-- // Comandos de chat
LocalPlayer.Chatted:Connect(function(message)
    if message:lower() == "/stopallbugs" then
        for _, connection in pairs(bugConnections) do
            if connection then connection:Disconnect() end
        end
        bugConnections = {}
        buggedPlayers = {}
        createNotification("ğŸ›‘ Todos os Bugs Parados", "Todos os players foram desbugados!")
    elseif message:lower() == "/buggedlist" then
        local count = 0
        for _ in pairs(buggedPlayers) do count = count + 1 end
        createNotification("ğŸ“‹ Lista de Bugados", count > 0 and (count.." players bugados") or "Nenhum player bugado")
    end
end)
